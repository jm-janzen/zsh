#!/bin/zsh

# reference to dir containing source files
zshdir=${0:h}

# reference to dir containing completion function files
fpath+="`dirname $0`/completions"

### shortcut functions to edit zsh configurations
function zedit () {
    file=$1
    case "$file" in
        aliases|functions|zshrc|completions)
            vi ${zshdir}/${file}
            ;;
        *)
            exit 0
            ;;
    esac
}

# TODO check if screen session of <fruit> name already exists
# before creating a same-named session.
function scn() {

    fruits=(
        grape       grapefruit  pomegranate)

    numFruits=${#fruits}

    if (( $# > 0 )) {
        screen $@
    } else {
        name=$fruits[$[RANDOM % numFruits + 1]]

        IFS=$'\n'
        screens=($(screen -ls | sed -nr 's/.*\d*\.([a-z]+)\s+[\(].*/\1/p'))
        num_screens=$#screens

        i=0
        # place loop in subshell, so exit only applies to it
        ( for s in $screens; do
            i++
            echo "Testing if $name matches $s..."
            if test "$name" != "$s" 
            then
                #screen -S "$name"
                echo $name
                exit
            else
                echo "I already put $name in your fruit salad; try again!"
            fi
        done )

    }
}

### convenience functions
function dump() {
    mv -i $1 $HOME/bups/$1
}
function dump-empty() {
    mv $HOME/bups/* $HOME/.bups/
}
function dump-ls() {
    ls -la $HOME/bups/
}
function notes() {
    if [[ -z $1 ]]; then
        echo 'Usage:\n\t notes [file] [pattern]'
    elif [[ $1 =~ "-h" ]]; then
        echo 'Usage:\n\t notes [file] [pattern]'
    elif [[ $1 =~ "-l" ]] || [[ $1 =~ "--list" ]]; then
        echo 'List of Help Files:\n------------------'
        \ls ${HOME}/notes | awk -F '.' ' /.txt/ { print $1 } '
    elif [[ -z $2 ]]; then
        less ${HOME}/notes/${1}.txt
    else
        grep -rh $HOME/notes/ --exclude-dir=".git" -e $1 | grep --color -C 10 $2
    fi
}

#
# A completely useless function, that just does what the name implies
#
function look-busy() {
    while (true) {
        for i in $(find . -name \*); do
            \ls $i
            for j in $i; do
                if [[ -d $j ]]; then
                    \ls -a $j
                else
                    od $j --width=40  -A x -t x1z -v | awk -F=' ' '{ print $0 }' | grep --color -e '>.\+'
                    sleep $[RANDOM % 3]
                fi
            done
        done
    }
}

function calc() {
    echo "$@" | bc
}

function grade() {
    print "scale=2; $1 / $2 * 100" | bc
}

